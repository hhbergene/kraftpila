# spec.py: Alle dataclasses + små fabrikkfunksjoner (defaults). Ingen runtime-logikk.
# tasks.py: Importerer fra spec.py og bygger TaskSpec-instanser (scene + regler).
# taskset.py: En liten “controller”:
# - holder liste/dict av oppgaver (fra tasks.py)
# - eksponerer current_task, next(), prev(), goto(id)
# - draw(canvas, task) for å tegne scene/guide (bruker render.py)
# - evaluate(forces) → kaller evaluate.py på aktiv TaskSpec
# evaluate.py: Én inngang, f.eks. evaluate_task(task: TaskSpec, forces) -> Feedback.
# - Bruker picking.py for å mappe brukerens krefter til ForceSpec
# - Sjekker navn/retning/pos med toleranser
# - Kjører relasjoner (ratioer) og likevekt (via problem_utils.sumF)
# - Returnerer delscorer + samlet score
# picking.py: Alt om “matching”: navn → alias, retning → vinkelavvik, fallback-prioritet (ankerpunkter/segment) når navn mangler. Her legger du regelen for oppg. 3 hvor to krefter peker ned: prioriter med pick_priority fra ForceSpec.
# problem_utils.py: sumF(forces, n_vec) (xy/np-variant), små helpers som ikke hører hjemme i generelle utils.geometry. Hold den lettvekts—kun det evaluering trenger.
# render.py: Tegnehint (vinkelbuer, kontaktsegment, punkt-“glow”), felles for alle check*.
# aliases.py: Samle alias-sett per kraft ett sted; importeres av tasks.py for gjenbruk.
# constants.py: ANG_TOL, ANG_SPAN, POS_TOL, … og Weights.
# geometry.py (valgfri): Scene-resolvere (AnchorPointRef → punkt/segment), hvis du ikke allerede bruker utils.geometry for dette.